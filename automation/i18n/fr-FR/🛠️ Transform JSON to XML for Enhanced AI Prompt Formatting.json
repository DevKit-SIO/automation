{
  "id": 5144,
  "name": "üõ†Ô∏è Transformer JSON en XML pour un formatage am√©lior√© des invites AI",
  "views": 1222,
  "recentViews": 2,
  "totalViews": 1222,
  "createdAt": "2025-06-23T09:48:08.695Z",
  "description": "## Aper√ßu\n\nCe mod√®le fournit un utilitaire puissant et configurable pour convertir des donn√©es JSON en un format XML propre et bien structur√©. Il est con√ßu pour les d√©veloppeurs, les analystes de donn√©es et les utilisateurs d'n8n qui ont besoin d'interfacer avec des syst√®mes h√©rit√©s, de g√©n√©rer des rapports structur√©s ou de pr√©parer des donn√©es pour la consommation par des mod√®les de langage de grande taille (LLM), qui pr√©sentent souvent une meilleure compr√©hension et un meilleur traitement avec des entr√©es au format XML.\n\n## Cas d'utilisation\n\nCe flux de travail est id√©al pour r√©soudre plusieurs probl√®mes courants de transformation de donn√©es :\n\n*   **Pr√©paration des donn√©es pour les invites AI :** Les LLM comme GPT-4 analysent souvent le XML de mani√®re plus fiable que le JSON dans une invite. Les balises de fermeture explicites et la nature hi√©rarchique du XML r√©duisent l'ambigu√Øt√©, conduisant √† de meilleures r√©ponses et plus coh√©rentes de l'IA.\n*   **Interfa√ßage avec des syst√®mes h√©rit√©s :** De nombreux syst√®mes d'entreprise, API SOAP et logiciels plus anciens acceptent ou produisent exclusivement des donn√©es au format XML. Ce mod√®le agit comme un pont, permettant aux services modernes bas√©s sur JSON de communiquer avec eux sans probl√®me.\n*   **G√©n√©ration de rapports structur√©s :** Cr√©ez des fichiers XML pour des normes de reporting ou d'√©change de donn√©es qui n√©cessitent une structure sp√©cifique et bien d√©finie.\n*   **Am√©lioration de la lisibilit√© des donn√©es :** Pour des donn√©es imbriqu√©es complexes, un XML bien format√© peut √™tre plus facile √† lire et √† d√©boguer pour les humains qu'une cha√Æne JSON compacte.\n\n## Comment √ßa fonctionne\n\nCe flux de travail agit comme un puissant convertisseur JSON en XML configurable. Il prend un objet JSON en entr√©e et effectue les √©tapes suivantes :\n\n1.  **Analyse r√©cursive du JSON :** Il navigue intelligemment √† travers toute la structure JSON, y compris les objets et tableaux imbriqu√©s.\n2.  **Gestion des types de donn√©es :**\n    *   **Tableaux primitifs** (par exemple, `[\"a\", \"b\", \"c\"]`) sont joints en une seule cha√Æne avec un d√©limiteur s√ªr.\n    *   **Tableaux complexes** (d'objets) sont convertis en balises XML index√©es (&lt;0&gt;, &lt;1&gt;, etc.).\n    *   **Dates** sont automatiquement d√©tect√©es et format√©es dans un format lisible `YYYY-MM-DD HH:mm:ss`.\n3.  **G√©n√®re une cha√Æne XML :** Il construit une cha√Æne XML finale bas√©e sur la logique et la configuration d√©finies dans le n≈ìud Code. La sortie est fournie dans un seul champ `xml`, pr√™te √† √™tre utilis√©e.\n\n## √âtapes de configuration\n\n**Temps de configuration : ~1 minute**\n\nCe flux de travail est con√ßu pour √™tre utilis√© comme un sous-flux de travail (ou \"flux de travail enfant\").\n\n1.  Dans votre flux de travail principal, ajoutez un n≈ìud **Ex√©cuter le flux de travail**.\n2.  Dans le param√®tre **Flux de travail** de ce n≈ìud, s√©lectionnez ce flux de travail \"Convertisseur JSON en XML\".\n3.  C'est tout ! Vous pouvez maintenant envoyer des donn√©es JSON au n≈ìud Ex√©cuter le flux de travail et il renverra la cha√Æne XML convertie dans le champ `xml`.\n\n## Options de personnalisation\n\nLe v√©ritable pouvoir de ce mod√®le r√©side dans sa personnalisation, g√©r√©e dans la section de configuration en haut du n≈ìud Code. Cela vous permet d'ajuster la sortie XML √† vos besoins exacts.\n\n*   **`REMOVE_EMPTY_VALUES`** : D√©fini sur `true` (par d√©faut) pour omettre compl√®tement les balises pour les valeurs `null`, `undefined` ou cha√Ænes vides, ce qui donne un XML plus propre. D√©fini sur `false` pour inclure des balises vides comme &lt;myTag&gt;&lt;/myTag&gt;.\n*   **Formatage des nouvelles lignes** : Contr√¥lez l'espacement et la lisibilit√© de la sortie avec quatre param√®tres distincts :\n    *   `NEWLINES_TOP_LEVEL` : Ajuste les nouvelles lignes entre les √©l√©ments de niveau racine.\n    *   `NEWLINES_ARRAY_ITEMS` : Contr√¥le l'espacement entre les √©l√©ments d'un tableau complexe (par exemple, entre &lt;0&gt; et &lt;1&gt;).\n    *   `NEWLINES_OBJECT_PROPERTIES` : G√®re les nouvelles lignes entre les propri√©t√©s d'un objet.\n    *   `NEWLINES_WITHIN_TAGS` : Ajoute des nouvelles lignes entre une balise d'ouverture/fermeture et son contenu pour un aspect \"indent√©\".\n\n## Pr√©requis\n\n*   Une instance n8n active.\n*   Familiarit√© de base avec les structures de donn√©es JSON et XML.\n*   Compr√©hension de l'utilisation du n≈ìud **Ex√©cuter le flux de travail** pour ex√©cuter des sous-flux de travail.",
  "workflow": {
    "meta": {
      "instanceId": "e409ea34548a2afe2dffba31130cd1cf2e98ebe2afaeed2a63caf2a0582d1da0"
    },
    "nodes": [
      {
        "id": "61e73730-2e9b-4882-82d0-b218958c0dc1",
        "name": "Convert JSON to XML",
        "type": "n8n-nodes-base.code",
        "position": [
          160,
          40
        ],
        "parameters": {
          "mode": "runOnceForEachItem",
          "jsCode": "// --- Configuration ---\nconst REMOVE_EMPTY_VALUES = true; // Omit empty tags\n\n// Newline configuration (number of '\\n')\nconst NEWLINES_TOP_LEVEL = 2;         // Between top-level elements (e.g., 2 for \\n\\n)\nconst NEWLINES_ARRAY_ITEMS = 2;       // Between <0>, <1>... elements of a complex array\nconst NEWLINES_OBJECT_PROPERTIES = 1; // Between <key1>, <key2>... properties of an object\nconst NEWLINES_WITHIN_TAGS = 1;       // Between opening/closing tag and its content (0, 1, 2...)\n\n// --- Input Retrieval ---\nconst inputJson = $input.item.json;\n\n// --- Utility Functions ---\n\n/**\n * Generates a string containing the specified number of newlines.\n * @param {number} count The desired number of newlines.\n * @returns {string} The newline string (e.g., \"\\n\", \"\\n\\n\").\n */\nfunction generateNewlines(count) {\n  return '\\n'.repeat(Math.max(0, count)); // Ensures a non-negative count\n}\n\n/**\n * Attempts to detect and format a value into a readable date (YYYY-MM-DD HH:mm:ss).\n * @param {any} value The value to check and format.\n * @returns {string|any} The formatted date if detected, otherwise the original value.\n */\nfunction formatIfDate(value) {\n  const originalValue = value;\n  let date = null;\n  try {\n    if (value instanceof Date && !isNaN(value.getTime())) {\n      date = value;\n    }\n    /* // Numeric timestamp detection (COMMENTED OUT)\n    else if (typeof value === 'number') { ... } */\n    else if (typeof value === 'string') {\n      // Basic check for string length and presence of digits/date separators\n      if (value.length >= 8 && /[0-9]/.test(value) && /[-/T:.\\s]/.test(value)) {\n        const parsedDate = new Date(value);\n        if (!isNaN(parsedDate.getTime())) {\n          date = parsedDate;\n        }\n      }\n    }\n    if (date instanceof Date && !isNaN(date.getTime())) {\n      const year = date.getFullYear();\n      const month = String(date.getMonth() + 1).padStart(2, '0');\n      const day = String(date.getDate()).padStart(2, '0');\n      const hours = String(date.getHours()).padStart(2, '0');\n      const minutes = String(date.getMinutes()).padStart(2, '0');\n      const seconds = String(date.getSeconds()).padStart(2, '0');\n      return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;\n    }\n  } catch (e) {\n    console.warn(`Error formatting date: ${value}`, e);\n    return originalValue;\n  }\n  return originalValue;\n}\n\n\n/**\n * Finds a safe delimiter to join elements of a primitive array.\n * @param {Array<any>} arr The array whose elements will be joined.\n * @returns {string} The found delimiter.\n */\nfunction findArrayDelimiter(arr) {\n  const stringElements = arr.map(el => String(el === null || el === undefined ? '' : el));\n  let delimiters = [',', '|'];\n  // Try common delimiters first\n  for (const d of delimiters) {\n    if (!stringElements.some(s => s.includes(d))) {\n      return d;\n    }\n  }\n  // If common delimiters are found in elements, create a unique one\n  let currentDelimiter = '||';\n  while (stringElements.some(s => s.includes(currentDelimiter))) {\n    currentDelimiter += '|';\n    if (currentDelimiter.length > 20) {\n      console.warn(\"Long delimiter used:\", arr);\n      return currentDelimiter; // Prevent infinite loop for extremely complex cases\n    }\n  }\n  return currentDelimiter;\n}\n\n/**\n * Checks if a value is a primitive (string, number, boolean, null, undefined).\n * @param {any} value The value to check.\n * @returns {boolean} True if it's a primitive.\n */\nfunction isPrimitive(value) {\n  const type = typeof value;\n  return value === null || type === 'undefined' || type === 'string' || type === 'number' || type === 'boolean';\n}\n\n\n/**\n * Recursive function to convert a JSON value into an XML fragment.\n * Uses configuration parameters for newlines.\n * Does NOT use XML escaping.\n * @param {any} value The JSON value to convert.\n * @param {string} tagName The XML tag name.\n * @returns {string} The generated XML fragment, or an empty string if the value is empty and should be omitted.\n */\nfunction jsonToXmlRecursive(value, tagName) {\n  const openTag = `<${tagName}>`;\n  const closeTag = `</${tagName}>`;\n\n  let processedValue = value;\n\n  // 1. Attempt to parse JSON/Array strings\n  if (typeof value === 'string') {\n    const trimmedValue = value.trim();\n    if (trimmedValue.startsWith('{') || trimmedValue.startsWith('[')) {\n      try {\n        processedValue = JSON.parse(trimmedValue);\n        console.log(`String parsed for tag: '${tagName}'.`);\n      } catch (e) {\n        processedValue = value; // Keep the original string if parsing fails\n        console.warn(`Parsing failed for tag: '${tagName}'. Error: ${e.message}`);\n      }\n    } else {\n      processedValue = trimmedValue; // Use the trimmed version for further processing\n    }\n  }\n\n  // 2. Initial check for null/undefined values\n  if (processedValue === null || processedValue === undefined) {\n    return REMOVE_EMPTY_VALUES ? '' : `${openTag}${closeTag}`;\n  }\n\n  // 3. Process based on type and calculate innerContent\n  let innerContent = '';\n  const nlArrayItemSep = generateNewlines(NEWLINES_ARRAY_ITEMS);\n  const nlObjectPropSep = generateNewlines(NEWLINES_OBJECT_PROPERTIES);\n\n  if (Array.isArray(processedValue)) {\n    if (processedValue.length === 0) {\n      return REMOVE_EMPTY_VALUES ? '' : `${openTag}${closeTag}`;\n    }\n\n    const elementsAfterDateFormatting = processedValue.map(el => formatIfDate(el));\n    const allPrimitives = elementsAfterDateFormatting.every(el => isPrimitive(el));\n\n    if (allPrimitives) { // Array of primitives -> join\n      const delimiter = findArrayDelimiter(elementsAfterDateFormatting);\n      const joinedString = elementsAfterDateFormatting\n        .map(el => String(el === null || el === undefined ? '' : el))\n        .join(delimiter)\n        .trim();\n      if (REMOVE_EMPTY_VALUES && joinedString === '') return '';\n      innerContent = joinedString;\n    } else { // Complex/mixed array -> iterate and join with configured separator\n      const innerParts = [];\n      processedValue.forEach((item, index) => {\n        const itemXml = jsonToXmlRecursive(item, String(index)); // Use index as tag name for array items\n        if (itemXml !== '') innerParts.push(itemXml);\n      });\n      if (REMOVE_EMPTY_VALUES && innerParts.length === 0) return '';\n      innerContent = innerParts.join(nlArrayItemSep); // Uses array item separator\n    }\n  } else if (typeof processedValue === 'object') {\n    if (Object.keys(processedValue).length === 0) {\n      return REMOVE_EMPTY_VALUES ? '' : `${openTag}${closeTag}`;\n    }\n    // Object -> iterate and join with configured separator\n    const innerParts = [];\n    for (const key in processedValue) {\n      if (Object.prototype.hasOwnProperty.call(processedValue, key)) {\n        const propertyXml = jsonToXmlRecursive(processedValue[key], key);\n        if (propertyXml !== '') innerParts.push(propertyXml);\n      }\n    }\n    if (REMOVE_EMPTY_VALUES && innerParts.length === 0) return '';\n    innerContent = innerParts.join(nlObjectPropSep); // Uses object property separator\n  } else { // Primitive\n    const finalValue = formatIfDate(processedValue);\n    const stringValue = String(finalValue === null || finalValue === undefined ? '' : finalValue).trim();\n    if (REMOVE_EMPTY_VALUES && stringValue === '') return '';\n    innerContent = stringValue;\n  }\n\n  // 4. Construct the final XML for this value WITH configured newlines\n  const nlWithin = generateNewlines(NEWLINES_WITHIN_TAGS);\n  if (innerContent === '') {\n    // If content is empty, no internal newlines\n    return `${openTag}${closeTag}`;\n  } else {\n    // If there is content, add the configured internal newlines\n    return `${openTag}${nlWithin}${innerContent}${nlWithin}${closeTag}`;\n  }\n}\n\n// --- Main Conversion Logic ---\n\nlet finalXmlParts = [];\nconst nlTopLevelSep = generateNewlines(NEWLINES_TOP_LEVEL); // Separator for level 1\n\nif (inputJson && typeof inputJson === 'object' && !Array.isArray(inputJson)) {\n  // If the input is a direct object, iterate its properties as top-level elements\n  for (const topLevelKey in inputJson) {\n    if (Object.prototype.hasOwnProperty.call(inputJson, topLevelKey)) {\n      const part = jsonToXmlRecursive(inputJson[topLevelKey], topLevelKey);\n      if (part !== '') finalXmlParts.push(part);\n    }\n  }\n} else if (inputJson !== null && inputJson !== undefined) {\n  // If the input is a primitive or an array, wrap it in a <root> tag\n  console.warn(\"Non-object input. Encapsulating in <root>.\");\n  const part = jsonToXmlRecursive(inputJson, \"root\");\n  if (part !== '') {\n    finalXmlParts.push(part);\n  } else {\n    console.warn(\"Entire input is empty and omitted.\");\n  }\n} else {\n  console.warn(\"Empty/invalid JSON input.\");\n}\n\n// Join the top-level XML fragments with the configured separator\nconst finalXmlString = finalXmlParts.join(nlTopLevelSep);\n\n// --- Output Preparation ---\nreturn {\n  xml: finalXmlString\n};"
        },
        "typeVersion": 2
      },
      {
        "id": "8206f932-d658-41db-a8bc-50568d18f495",
        "name": "JSON to XML",
        "type": "n8n-nodes-base.executeWorkflowTrigger",
        "position": [
          -120,
          40
        ],
        "parameters": {
          "inputSource": "passthrough"
        },
        "typeVersion": 1.1
      },
      {
        "id": "9e3350b9-b6ad-4993-8cef-995ff73eb4cd",
        "name": "Sticky Note",
        "type": "n8n-nodes-base.stickyNote",
        "position": [
          -1100,
          -400
        ],
        "parameters": {
          "color": 6,
          "width": 880,
          "height": 600,
          "content": "## JSON to XML Converter (Code Node)\n\nThis workflow utilizes a custom Code node to transform a JSON input into an XML structure. It offers flexibility in formatting and handling empty values.\n\n### Key Features:\n*   **Recursive conversion** from JSON to XML.\n*   **Array Handling:**\n    *   Primitive arrays are **joined with a safe delimiter** (e.g., `val1,val2`).\n    *   Complex arrays are converted into `<0>`, `<1>`, etc., tags.\n*   **Date detection and formatting** (YYYY-MM-DD HH:mm:ss).\n*   **Attempted parsing** of JSON/Array strings contained within values.\n*   **Encapsulates non-object input** within a `<root>` tag.\n\n---\n\n### Input:\n\n*   A single item (process each item in the subworkflow).\n\n### Output:\n\n*   An object with an `xml` property containing the generated XML string, very useful for AI prompts."
        },
        "typeVersion": 1
      },
      {
        "id": "0e34e239-4490-44cc-8531-8869df671b90",
        "name": "Sticky Note1",
        "type": "n8n-nodes-base.stickyNote",
        "position": [
          20,
          -480
        ],
        "parameters": {
          "color": 5,
          "width": 400,
          "height": 680,
          "content": "### Configuration (within the code):\n\n*   **`REMOVE_EMPTY_VALUES`** (boolean): Omits XML tags if their content is empty (default: `true`).\n*   **Configurable Newlines** (`NEWLINES_TOP_LEVEL`, `NEWLINES_ARRAY_ITEMS`, `NEWLINES_OBJECT_PROPERTIES`, `NEWLINES_WITHIN_TAGS`): Controls indentation and readability of the generated XML.\n\n---\n\n### ‚ö†Ô∏è IMPORTANT / NOTE ‚ö†Ô∏è:\n\n*   **No XML escaping for special characters** (e.g., <, >, &, ', \"). If your JSON contains these characters in values, they will be inserted as-is into the XML, which might render the XML invalid or vulnerable. A manual escaping step might be necessary if this is an issue.\n*   This node is a custom script. Any modifications or maintenance must be done directly within the code."
        },
        "typeVersion": 1
      },
      {
        "id": "d5ea7df1-d2a0-420a-ac69-527b712b6691",
        "name": "Sticky Note12",
        "type": "n8n-nodes-base.stickyNote",
        "position": [
          460,
          -600
        ],
        "parameters": {
          "color": 4,
          "width": 540,
          "height": 800,
          "content": "## Was this helpful? Let me know!\n\nI really hope this template helped you use data more efficiently. Your feedback is incredibly valuable and helps me create better resources for the n8n community.\n\n### **Share Your Thoughts & Ideas**\n\nWhether you have a suggestion, found a typo, or just want to say thanks, I'd love to hear from you!\nHere's a simple n8n form built for this purpose:\n\n#### ‚û°Ô∏è **[Click here to give feedback](https://api.ia2s.app/form/templates/feedback?template=JSON%20to%20XML)**\n\n### **Ready to Build Something Great?**\n\nIf you're looking to take your n8n skills or business automation to the next level, I can help.\n\n**üéì n8n Coaching:** Want to become an n8n pro? I offer one-on-one coaching sessions to help you master workflows, tackle specific problems, and build with confidence.\n#### ‚û°Ô∏è **[Book a Coaching Session](https://api.ia2s.app/form/templates/coaching?template=JSON%20to%20XML)**\n\n**üíº n8n Consulting:** Have a complex project, an integration challenge, or need a custom workflow built for your business? Let's work together to create a powerful automation solution.\n#### ‚û°Ô∏è **[Inquire About Consulting Services](https://api.ia2s.app/form/templates/consulting?template=JSON%20to%20XML)**\n\n---\n\nHappy Automating!\nLucas Peyrin"
        },
        "typeVersion": 1
      }
    ],
    "pinData": {
      "JSON to XML": [
        {
          "aField": "a string",
          "aNumber": 123,
          "anArray": [],
          "thisFieldAcceptsAnyType": null
        }
      ]
    },
    "connections": {
      "JSON to XML": {
        "main": [
          [
            {
              "node": "Convert JSON to XML",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    }
  },
  "lastUpdatedBy": 29,
  "workflowInfo": {
    "nodeCount": 5,
    "nodeTypes": {
      "n8n-nodes-base.code": {
        "count": 1
      },
      "n8n-nodes-base.stickyNote": {
        "count": 3
      },
      "n8n-nodes-base.executeWorkflowTrigger": {
        "count": 1
      }
    }
  },
  "user": {
    "name": "Lucas Peyrin",
    "username": "lucaspeyrin",
    "bio": "Innovative builder with a passion for crafting automation solutions that solve real-world challenges. From streamlining workflows to driving efficiency, my work empowers teams and individuals to achieve more with less effort. Experienced in developing scalable tools and strategies that deliver results with n8n, supabase and cline.\n\nJoin the N8N Academy:",
    "verified": true,
    "links": [
      "https://skool.n8n.ac"
    ],
    "avatar": "https://gravatar.com/avatar/74234187cf4a650d53f6a86e7b03d1bcb8cfef4cbd0552eabd8d966cd808cc54?r=pg&d=retro&size=200"
  },
  "nodes": [
    {
      "id": 565,
      "icon": "fa:sticky-note",
      "name": "n8n-nodes-base.stickyNote",
      "codex": {
        "data": {
          "alias": [
            "Comments",
            "Notes",
            "Sticky"
          ],
          "categories": [
            "Core Nodes"
          ],
          "nodeVersion": "1.0",
          "codexVersion": "1.0",
          "subcategories": {
            "Core Nodes": [
              "Helpers"
            ]
          }
        }
      },
      "group": "[\"input\"]",
      "defaults": {
        "name": "Note collante",
        "color": "#FFD233"
      },
      "iconData": {
        "icon": "sticky-note",
        "type": "icon"
      },
      "displayName": "Sticky Note",
      "typeVersion": 1,
      "nodeCategories": [
        {
          "id": 9,
          "name": "Core Nodes"
        }
      ]
    },
    {
      "id": 834,
      "icon": "file:code.svg",
      "name": "n8n-nodes-base.code",
      "codex": {
        "data": {
          "alias": [
            "cpde",
            "Javascript",
            "JS",
            "Python",
            "Script",
            "Custom Code",
            "Function"
          ],
          "details": "The Code node allows you to execute JavaScript in your workflow.",
          "resources": {
            "primaryDocumentation": [
              {
                "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.code/"
              }
            ]
          },
          "categories": [
            "Development",
            "Core Nodes"
          ],
          "nodeVersion": "1.0",
          "codexVersion": "1.0",
          "subcategories": {
            "Core Nodes": [
              "Helpers",
              "Data Transformation"
            ]
          }
        }
      },
      "group": "[\"transform\"]",
      "defaults": {
        "name": "Code"
      },
      "iconData": {
        "type": "file",
        "fileBuffer": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8xMTcxXzQ0MSkiPgo8cGF0aCBkPSJNMTcwLjI4MyA0OEgxOTYuNUMyMDMuMTI3IDQ4IDIwOC41IDQyLjYyNzQgMjA4LjUgMzZWMTJDMjA4LjUgNS4zNzI1OCAyMDMuMTI3IDAgMTk2LjUgMEgxNzAuMjgzQzEyNi4xIDAgOTAuMjgzIDM1LjgxNzIgOTAuMjgzIDgwVjE3NkM5MC4yODMgMjA2LjkyOCA2NS4yMTA5IDIzMiAzNC4yODMgMjMySDIzQzE2LjM3MjYgMjMyIDExIDIzNy4zNzIgMTEgMjQ0VjI2OEMxMSAyNzQuNjI3IDE2LjM3MjQgMjgwIDIyLjk5OTYgMjgwTDM0LjI4MyAyODBDNjUuMjEwOSAyODAgOTAuMjgzIDMwNS4wNzIgOTAuMjgzIDMzNlY0NDBDOTAuMjgzIDQ3OS43NjQgMTIyLjUxOCA1MTIgMTYyLjI4MyA1MTJIMTk2LjVDMjAzLjEyNyA1MTIgMjA4LjUgNTA2LjYyNyAyMDguNSA1MDBWNDc2QzIwOC41IDQ2OS4zNzMgMjAzLjEyNyA0NjQgMTk2LjUgNDY0SDE2Mi4yODNDMTQ5LjAyOCA0NjQgMTM4LjI4MyA0NTMuMjU1IDEzOC4yODMgNDQwVjMzNkMxMzguMjgzIDMwOS4wMjIgMTI4LjAxMSAyODQuNDQzIDExMS4xNjQgMjY1Ljk2MUMxMDYuMTA5IDI2MC40MTYgMTA2LjEwOSAyNTEuNTg0IDExMS4xNjQgMjQ2LjAzOUMxMjguMDExIDIyNy41NTcgMTM4LjI4MyAyMDIuOTc4IDEzOC4yODMgMTc2VjgwQzEzOC4yODMgNjIuMzI2OSAxNTIuNjEgNDggMTcwLjI4MyA0OFoiIGZpbGw9IiNGRjk5MjIiLz4KPHBhdGggZD0iTTMwNSAzNkMzMDUgNDIuNjI3NCAzMTAuMzczIDQ4IDMxNyA0OEgzNDIuOTc5QzM2MC42NTIgNDggMzc0Ljk3OCA2Mi4zMjY5IDM3NC45NzggODBWMTc2QzM3NC45NzggMjAyLjk3OCAzODUuMjUxIDIyNy41NTcgNDAyLjA5OCAyNDYuMDM5QzQwNy4xNTMgMjUxLjU4NCA0MDcuMTUzIDI2MC40MTYgNDAyLjA5OCAyNjUuOTYxQzM4NS4yNTEgMjg0LjQ0MyAzNzQuOTc4IDMwOS4wMjIgMzc0Ljk3OCAzMzZWNDMyQzM3NC45NzggNDQ5LjY3MyAzNjAuNjUyIDQ2NCAzNDIuOTc5IDQ2NEgzMTdDMzEwLjM3MyA0NjQgMzA1IDQ2OS4zNzMgMzA1IDQ3NlY1MDBDMzA1IDUwNi42MjcgMzEwLjM3MyA1MTIgMzE3IDUxMkgzNDIuOTc5QzM4Ny4xNjEgNTEyIDQyMi45NzggNDc2LjE4MyA0MjIuOTc4IDQzMlYzMzZDNDIyLjk3OCAzMDUuMDcyIDQ0OC4wNTEgMjgwIDQ3OC45NzkgMjgwSDQ5MEM0OTYuNjI3IDI4MCA1MDIgMjc0LjYyOCA1MDIgMjY4VjI0NEM1MDIgMjM3LjM3MyA0OTYuNjI4IDIzMiA0OTAgMjMyTDQ3OC45NzkgMjMyQzQ0OC4wNTEgMjMyIDQyMi45NzggMjA2LjkyOCA0MjIuOTc4IDE3NlY4MEM0MjIuOTc4IDM1LjgxNzIgMzg3LjE2MSAwIDM0Mi45NzkgMEgzMTdDMzEwLjM3MyAwIDMwNSA1LjM3MjU4IDMwNSAxMlYzNloiIGZpbGw9IiNGRjk5MjIiLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8xMTcxXzQ0MSI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo="
      },
      "displayName": "Code",
      "typeVersion": 2,
      "nodeCategories": [
        {
          "id": 5,
          "name": "Development"
        },
        {
          "id": 9,
          "name": "Core Nodes"
        }
      ]
    },
    {
      "id": 837,
      "icon": "fa:sign-out-alt",
      "name": "n8n-nodes-base.executeWorkflowTrigger",
      "codex": {
        "data": {
          "resources": {
            "generic": [],
            "primaryDocumentation": [
              {
                "url": "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.executeworkflowtrigger/"
              }
            ]
          },
          "categories": [
            "Core Nodes"
          ],
          "nodeVersion": "1.0",
          "codexVersion": "1.0",
          "subcategories": {
            "Core Nodes": [
              "Helpers"
            ]
          }
        }
      },
      "group": "[\"trigger\"]",
      "defaults": {
        "name": "Lorsqu'il est ex√©cut√© par un autre flux de travail",
        "color": "#ff6d5a"
      },
      "iconData": {
        "icon": "sign-out-alt",
        "type": "icon"
      },
      "displayName": "Execute Workflow Trigger",
      "typeVersion": 1,
      "nodeCategories": [
        {
          "id": 9,
          "name": "Core Nodes"
        }
      ]
    }
  ],
  "categories": [
    {
      "id": 5,
      "name": "Ing√©nierie"
    }
  ],
  "image": []
}